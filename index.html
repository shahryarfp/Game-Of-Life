<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Conway's Game of Life - Mobile Optimized</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background-color: #121212;
      display: flex;
      flex-direction: column; /* Main axis is vertical now */
      color: #fff;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      overflow: hidden;
      position: fixed;
    }

    #main {
      flex-grow: 1; /* Takes up available space above the bottom sidebar */
      display: flex;
      flex-direction: column;
      box-sizing: border-box;
      overflow: hidden;
      position: relative;  
    }

    #sidebar {
      width: 100%;  
      height: 200px;  
      background-color: #1e1e1e;
      border-top: 2px solid #333;  
      display: flex;
      flex-direction: column;  
      box-sizing: border-box;
      transition: height 0.3s ease;  
      flex-shrink: 0;  
      z-index: 100;
    }

    #sidebar.collapsed {
      height: 45px;  
    }

    #toggleSidebarBtn {
      font-size: 1.5rem;
      text-align: center;
      background-color: #1e1e1e;
      border: none;
      cursor: pointer;
      color: #fff;
      padding: 8px 0;  
      width: 100%;
      box-sizing: border-box;
      flex-shrink: 0;
      transition: background-color 0.2s;
      -webkit-tap-highlight-color: transparent;
    }

    #toggleSidebarBtn:hover, #toggleSidebarBtn:active {
      background-color: #333;
      color: #00FFFF;
    }

    #sidebar h2 {
      margin: 5px 10px;  
      font-size: 1rem;  
      text-align: center;
      padding-bottom: 5px;
      flex-shrink: 0;
    }

    #sidebar.collapsed h2 {
      display: none;
    }

    #shapePalette {
      display: flex;
      flex-direction: row;  
      gap: 15px;
      padding: 10px;
      box-sizing: border-box;
      overflow-x: auto;  
      overflow-y: hidden;
      flex-grow: 1;  
      -webkit-overflow-scrolling: touch;
      align-items: center;  
    }

    #sidebar.collapsed #shapePalette {
      display: none;
    }

    .shape-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      font-size: 0.8rem;
      flex-shrink: 0;  
    }

    .shapeCanvas {
      border: 1px solid #333;
      background-color: #161616;
      cursor: grab;
      width: 70px;
      height: 70px;
    }

    h1 {
      margin: 10px 0;
      font-size: 1.8rem;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
      align-self: center;
      text-align: center;
    }

    #controls {
      margin: 10px 0;
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 0 10px;
      box-sizing: border-box;
      align-items: center;
    }

    .control-row {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      justify-content: center;
      width: 100%;
    }
    .control-row.multi-item {
      flex-direction: row;
      justify-content: space-around;
    }

    #controls button, #controls input[type="range"], #controls label {
      padding: 10px 15px;
      background-color: #1e1e1e;
      border: none;
      border-radius: 8px;
      color: #fff;
      cursor: pointer;
      transition: background-color 0.2s;
      font-size: 0.9rem;
      -webkit-tap-highlight-color: transparent;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    #controls button {
      min-width: 120px;
      text-align: center;
    }

    #controls button:hover, #controls input[type="range"]:hover,
    #controls button:active, #controls input[type="range"]:active {
      background-color: #333;
    }

    #controls input[type="range"] {
      width: 70%;
      max-width: 200px;
      padding: 5px 0;
    }
    #controls label {
      background-color: transparent;
      box-shadow: none;
      padding: 5px;
    }

    #canvasContainer {
      flex-grow: 1;  
      display: flex;
      justify-content: center;
      align-items: center;
      box-sizing: border-box;
      position: relative;  
      padding: 5px;
      min-height: 0;  
      overflow: hidden;
      touch-action: none;
    }

    #gameCanvas {
      border: 1px solid #444;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.15);
      background-color: #1e1e1e;
      cursor: crosshair;
      display: block;
      image-rendering: pixelated;
      image-rendering: -moz-crisp-edges;
      image-rendering: crisp-edges;
    }

    @media (min-width: 768px) {
      #sidebar {
        height: 220px;  
      }
      #sidebar.collapsed {
        height: 45px;  
      }
      #sidebar h2 {
        font-size: 1.1rem;
        margin: 8px 15px;
      }
      #shapePalette {
        padding: 15px;
      }
      h1 {
        font-size: 2rem;
      }
      #controls {
        flex-direction: row;
        justify-content: center;
        gap: 15px;
        padding: 0 20px;
      }
      .control-row {
        flex-direction: row;
        width: auto;
      }
      #controls button {
        min-width: auto;
      }
      #controls input[type="range"] {
        width: 150px;
      }
      #canvasContainer {
        padding: 10px;
      }
    }

    @media (max-width: 360px) {
      h1 {
        font-size: 1.5rem;
      }
      #controls button {
        padding: 8px 10px;
        font-size: 0.8rem;
      }
      .shapeCanvas {
        width: 60px;
        height: 60px;
      }
       #sidebar {
        height: 180px;  
      }
    }
  </style>
</head>
<body>
  <div id="main">
    <h1>Conway's Game of Life</h1>
    <div id="controls">
      <div class="control-row">
        <button id="startStopBtn">Start</button>
        <button id="resetBtn">Reset</button>
      </div>
      <div class="control-row">
        <label for="speedRange">Speed:</label>
        <input type="range" id="speedRange" min="1" max="20" value="10">
      </div>
      <div class="control-row multi-item">
        <button id="randomBtn">Randomize</button>
        <button id="clearBtn">Clear</button>
      </div>
    </div>
    <div id="canvasContainer">
      <canvas id="gameCanvas"></canvas>
    </div>
  </div>

  <div id="sidebar">
    <button id="toggleSidebarBtn">â–¼</button>  
    <h2>Shapes</h2>
    <div id="shapePalette">
      </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    // Grid dimensions (number of cells)
    const rows = 80;  
    const cols = 80;
    let cellSize; // Size of each cell in pixels, will be calculated
    let grid = createEmptyGrid();
    let running = false;
    let timeoutId = null;
    let speed = 10; // Default speed (updates per second)
    let initialGrid = createEmptyGrid(); // Stores the grid state before starting or after manual edits

    // DOM Elements
    const startStopBtn = document.getElementById('startStopBtn');
    const resetBtn = document.getElementById('resetBtn');
    const randomBtn = document.getElementById('randomBtn');
    const clearBtn = document.getElementById('clearBtn');
    const speedRange = document.getElementById('speedRange');
    const shapePalette = document.getElementById('shapePalette');
    const canvasContainer = document.getElementById('canvasContainer');
    const sidebar = document.getElementById('sidebar');
    const toggleSidebarBtn = document.getElementById('toggleSidebarBtn');

    // Panning and Zooming variables
    let viewOffsetX = 0; // Top-left corner of the viewport in grid coordinates
    let viewOffsetY = 0;
    let isPanning = false;
    let lastPanX, lastPanY;

    const MIN_CELL_SIZE_DESKTOP = 2; // Minimum cell size for desktop
    const MIN_CELL_SIZE_MOBILE = 4;  // Minimum cell size for mobile (larger for touch)
    let currentMinCellSize = window.innerWidth < 768 ? MIN_CELL_SIZE_MOBILE : MIN_CELL_SIZE_DESKTOP;
    const MAX_CELL_SIZE = 100; // Maximum cell size
    let initialCellSizeSetup = true; // Flag to set initial zoom and pan

    let pinchStartDistance = null; // For pinch-to-zoom

    // Variables for tap detection
    let touchStartX, touchStartY, touchStartTime;
    const TAP_THRESHOLD = 10; // Max distance in pixels for a touch to be considered a tap
    const TAP_DURATION_THRESHOLD = 250; // Max duration in ms for a touch to be considered a tap


    // --- Shape Definitions ---
    // Each shape is an array of [row, col] offsets from the top-left of the pattern.
    const shapes = {
      Glider: [[0,1],[1,2],[2,0],[2,1],[2,2]],
      Blinker: [[0,0],[0,1],[0,2]], // Oscillator (period 2)
      Toad: [[0,1],[0,2],[0,3],[1,0],[1,1],[1,2]], // Oscillator (period 2)
      Beacon: [[0,0],[0,1],[1,0],[1,1],[2,2],[2,3],[3,2],[3,3]], // Oscillator (period 2)
      Block: [[0,0],[0,1],[1,0],[1,1]], // Still life
      Beehive: [[0,1],[0,2],[1,0],[1,3],[2,1],[2,2]], // Still life
      Loaf: [[0,1],[0,2],[1,0],[1,3],[2,1],[2,4],[3,2],[3,3]], // Still life
      Boat: [[0,0],[0,1],[1,0],[1,2],[2,1]], // Still life
      Tub: [[0,1],[1,0],[1,2],[2,1]], // Still life
      Rpento: [[0,1],[0,2],[1,0],[1,1],[2,1]], // Methuselah (stabilizes after 1103 generations)
      Diehard: [[0,6],[1,0],[1,1],[2,1],[2,5],[2,6],[2,7]], // Methuselah (dies after 130 generations)
      Acorn: [[0,1],[1,3],[2,0],[2,1],[2,4],[2,5],[2,6]], // Methuselah (stabilizes after 5206 generations)
      // --- NEW SHAPES ADDED BELOW ---
      LWSS: [[0,0],[0,3], [1,0],[1,4], [2,0],[2,1],[2,2],[2,3],[2,4], [3,1],[3,3]], // Lightweight Spaceship
      Pulsar: [ // Oscillator (period 3)
        [0,2],[0,3],[0,4], [0,8],[0,9],[0,10],
        [2,0],[2,5],[2,7],[2,12], [3,0],[3,5],[3,7],[3,12], [4,0],[4,5],[4,7],[4,12],
        [5,2],[5,3],[5,4], [5,8],[5,9],[5,10],
        // row 6 is empty
        [7,2],[7,3],[7,4], [7,8],[7,9],[7,10],
        [8,0],[8,5],[8,7],[8,12], [9,0],[9,5],[9,7],[9,12], [10,0],[10,5],[10,7],[10,12],
        // row 11 is empty
        [12,2],[12,3],[12,4], [12,8],[12,9],[12,10]
      ],
      Pentadecathlon: [ // Oscillator (period 15)
        [0,2],[0,7],
        [1,0],[1,1],[1,3],[1,4],[1,5],[1,6],[1,8],[1,9],
        [2,2],[2,7]
      ],
      GosperGun: [ // Gosper Glider Gun (produces gliders)
        [0,24],[1,22],[1,24],[2,12],[2,13],[2,20],[2,21],[2,34],[2,35],
        [3,11],[3,15],[3,20],[3,21],[3,34],[3,35],
        [4,0],[4,1],[4,10],[4,16],[4,20],[4,21],
        [5,0],[5,1],[5,10],[5,14],[5,16],[5,17],[5,22],[5,24],
        [6,10],[6,16],[6,24],[7,11],[7,15],[8,12],[8,13]
      ],
      Pond: [[0,1],[0,2],[1,0],[1,3],[2,0],[2,3],[3,1],[3,2]] // Still life
    };
    const previewSize = 70; // Size of the preview canvas for shapes

    // --- Shape Palette Creation ---
    function createShapePreviews() {
      shapePalette.innerHTML = ''; // Clear existing previews
      for (let [name, pattern] of Object.entries(shapes)) {
        const container = document.createElement('div');
        container.classList.add('shape-container');
        
        const label = document.createElement('div');
        label.textContent = name;
        label.style.marginBottom = '5px';

        const shapeCanvasEl = document.createElement('canvas'); 
        shapeCanvasEl.width = previewSize;
        shapeCanvasEl.height = previewSize;
        shapeCanvasEl.classList.add('shapeCanvas');
        shapeCanvasEl.draggable = true; // Make the canvas draggable
        shapeCanvasEl.dataset.shape = name; // Store shape name for drag data

        const sCtx = shapeCanvasEl.getContext('2d');
        sCtx.fillStyle = '#161616'; // Background for preview
        sCtx.fillRect(0, 0, previewSize, previewSize);

        // Determine dimensions of the pattern to scale it correctly
        let maxRow = 0, maxCol = 0;
        pattern.forEach(([r, c]) => {
          if (r > maxRow) maxRow = r;
          if (c > maxCol) maxCol = c;
        });
        const rowsUsed = maxRow + 1;
        const colsUsed = maxCol + 1;

        // Calculate cell size for preview, ensuring it's at least 1px
        const previewCellSize = Math.max(1, Math.floor(previewSize / Math.max(rowsUsed, colsUsed, 1)));
        
        // Center the pattern in the preview canvas
        const offsetX = (previewSize - colsUsed * previewCellSize) / 2;
        const offsetY = (previewSize - rowsUsed * previewCellSize) / 2;

        sCtx.fillStyle = '#00FFFF'; // Color of live cells in preview
        pattern.forEach(([r, c]) => {
          // Draw slightly smaller cells to show grid lines if cell size is large enough
          sCtx.fillRect(offsetX + c * previewCellSize, offsetY + r * previewCellSize, previewCellSize -0.5, previewCellSize -0.5);
        });

        // Optionally draw grid lines in preview if cells are large enough
        sCtx.strokeStyle = '#333';
        sCtx.lineWidth = 0.5;
        if (previewCellSize > 3) { // Only draw grid if cells are reasonably visible
          for (let i = 0; i < rowsUsed; i++) {
            for (let j = 0; j < colsUsed; j++) {
              sCtx.strokeRect(offsetX + j * previewCellSize, offsetY + i * previewCellSize, previewCellSize, previewCellSize);
            }
          }
        }
        
        // Event listener for dragging shapes
        shapeCanvasEl.addEventListener('dragstart', (event) => {
          event.dataTransfer.setData('text/plain', name);
          // You can also set a drag image if desired:
          // event.dataTransfer.setDragImage(shapeCanvasEl, previewSize / 2, previewSize / 2);
        });

        container.appendChild(label);
        container.appendChild(shapeCanvasEl);
        shapePalette.appendChild(container);
      }
    }

    // --- Canvas Sizing and Drawing ---
    function resizeCanvas() {
      currentMinCellSize = window.innerWidth < 768 ? MIN_CELL_SIZE_MOBILE : MIN_CELL_SIZE_DESKTOP;
      // Ensure canvasContainer has dimensions before proceeding
      if (!canvasContainer.clientWidth || !canvasContainer.clientHeight) {
        requestAnimationFrame(resizeCanvas); // Try again on next frame
        return;
      }

      const containerWidth = canvasContainer.clientWidth;
      const containerHeight = canvasContainer.clientHeight;
      if (containerWidth <= 0 || containerHeight <= 0) return;


      // Store old canvas center in grid coordinates to maintain view
      const oldCanvasWidth = canvas.width;
      const oldCanvasHeight = canvas.height;
      let centerXGrid = viewOffsetX + (oldCanvasWidth / 2 / (cellSize || currentMinCellSize));
      let centerYGrid = viewOffsetY + (oldCanvasHeight / 2 / (cellSize || currentMinCellSize));


      canvas.width = containerWidth;
      canvas.height = containerHeight;
      ctx.imageSmoothingEnabled = false; // Keep pixels sharp

      if (initialCellSizeSetup) {
        // Calculate initial cell size to fit the grid (or a portion of it)
        let initialFitCellSize = Math.floor(Math.min(containerWidth / cols, containerHeight / rows));
        // For mobile, show a smaller portion of the grid initially (more zoomed in)
        if (window.innerWidth < 768) {
             initialFitCellSize = Math.floor(Math.min(containerWidth / (cols/1.5), containerHeight / (rows/1.5)));
        }
        cellSize = Math.max(currentMinCellSize, initialFitCellSize);
        
        // Center the initial view
        viewOffsetX = (cols - containerWidth / cellSize) / 2;
        viewOffsetY = (rows - containerHeight / cellSize) / 2;
        initialCellSizeSetup = false;
      } else {
         // Recalculate viewOffset to keep the same center point after resize/zoom
        if (cellSize > 0) { // cellSize should always be positive
            viewOffsetX = centerXGrid - (canvas.width / 2 / cellSize);
            viewOffsetY = centerYGrid - (canvas.height / 2 / cellSize);
        } else { // Fallback, should not happen if cellSize is managed correctly
            cellSize = currentMinCellSize;
            viewOffsetX = (cols - containerWidth / cellSize) / 2;
            viewOffsetY = (rows - containerHeight / cellSize) / 2;
        }
      }
      clampViewOffset();
      drawGrid();
    }
    
    // Ensure viewOffset stays within grid boundaries
    function clampViewOffset() {
      if (typeof cellSize === 'undefined' || cellSize <= 0) return; // Guard against undefined/invalid cellSize
      if (!canvas.width || !canvas.height) return; // Guard against zero canvas dimensions

      // If grid is smaller than canvas, center it
      if (cols * cellSize < canvas.width) {
        viewOffsetX = (cols * cellSize - canvas.width) / (2 * cellSize); // Negative offset to center
      } else {
        // Otherwise, clamp to boundaries
        const minX = 0;
        const maxX = Math.max(0, cols - (canvas.width / cellSize));
        viewOffsetX = Math.max(minX, Math.min(viewOffsetX, maxX));
      }

      if (rows * cellSize < canvas.height) {
        viewOffsetY = (rows * cellSize - canvas.height) / (2 * cellSize); // Negative offset to center
      } else {
        const minY = 0;
        const maxY = Math.max(0, rows - (canvas.height / cellSize));
        viewOffsetY = Math.max(minY, Math.min(viewOffsetY, maxY));
      }
    }

    window.addEventListener('resize', resizeCanvas);
    // Initial call to resize and draw, slight delay to ensure layout is stable
    setTimeout(resizeCanvas, 100); 

    // --- Sidebar Toggle ---
    toggleSidebarBtn.addEventListener('click', () => {
      sidebar.classList.toggle('collapsed');
      toggleSidebarBtn.textContent = sidebar.classList.contains('collapsed') ? 'â–²' : 'â–¼';
      // Recalculate canvas size after sidebar animation
      setTimeout(resizeCanvas, 310); // Delay should match sidebar transition time
    });

    // --- Initialize Shape Previews ---
    createShapePreviews();


    // --- Zooming Logic ---
    function applyZoom(zoomFactor, mouseX, mouseY) {
        if (typeof cellSize === 'undefined') return;
        // Calculate mouse position in grid coordinates before zoom
        const mouseGridX_before = (mouseX / cellSize) + viewOffsetX;
        const mouseGridY_before = (mouseY / cellSize) + viewOffsetY;

        let newCellSize = cellSize * zoomFactor;
        newCellSize = Math.max(currentMinCellSize, Math.min(MAX_CELL_SIZE, newCellSize));

        if (newCellSize === cellSize) return; // No change in zoom

        cellSize = newCellSize;

        // Adjust viewOffset to keep the point under the mouse stationary
        viewOffsetX = mouseGridX_before - (mouseX / cellSize);
        viewOffsetY = mouseGridY_before - (mouseY / cellSize);

        clampViewOffset();
        drawGrid();
    }
    
    // Mouse wheel zoom
    canvas.addEventListener('wheel', (event) => {
      event.preventDefault(); // Prevent page scrolling
      const rect = canvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;
      const zoomFactor = event.deltaY < 0 ? 1.1 : 0.9; // Zoom in or out
      applyZoom(zoomFactor, mouseX, mouseY);
    }, { passive: false });


    // --- Panning Logic ---
    function startPan(clientX, clientY) {
        isPanning = true;
        lastPanX = clientX;
        lastPanY = clientY;
        canvas.style.cursor = 'grabbing';
    }

    function movePan(clientX, clientY) {
        if (!isPanning || typeof cellSize === 'undefined' || cellSize <= 0) return;
        const dx = clientX - lastPanX;
        const dy = clientY - lastPanY;

        viewOffsetX -= dx / cellSize;
        viewOffsetY -= dy / cellSize;

        lastPanX = clientX;
        lastPanY = clientY;

        clampViewOffset();
        drawGrid();
    }

    function stopPan() {
        if (isPanning) {
            isPanning = false;
            canvas.style.cursor = running ? 'grab' : 'crosshair'; // Revert cursor based on game state
        }
        pinchStartDistance = null; // Reset for pinch zoom
    }

    // --- Mouse Panning ---
    canvas.addEventListener('mousedown', (event) => {
      if (event.button !== 0) return; // Only pan with left mouse button
      if (event.target !== canvas) return; // Ensure click is on canvas itself
      // Do not start pan if a shape is being dragged from palette (already handled by draggable)
      if (event.target.classList.contains('shapeCanvas')) return;
      startPan(event.clientX, event.clientY);
    });
    canvas.addEventListener('mousemove', (event) => {
      movePan(event.clientX, event.clientY);
    });
    window.addEventListener('mouseup', stopPan); // Stop panning if mouse is released anywhere
    canvas.addEventListener('mouseleave', stopPan); // Stop panning if mouse leaves canvas


    // --- Touch Panning, Pinch Zoom, and Tap ---
    canvas.addEventListener('touchstart', (event) => {
        // Using touch-action: none on canvasContainer, so preventDefault might not be strictly needed here for panning/zooming.
        // However, it's good for tap to prevent emulated mouse events.
        if (event.touches.length === 1) {
            const touch = event.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchStartTime = Date.now();
            // We call startPan, but a very short touch will be treated as a tap in touchend
            startPan(touch.clientX, touch.clientY);
        } else if (event.touches.length === 2) {
            isPanning = false; // Stop single-touch panning if two fingers are down
            const dx = event.touches[0].clientX - event.touches[1].clientX;
            const dy = event.touches[0].clientY - event.touches[1].clientY;
            pinchStartDistance = Math.sqrt(dx * dx + dy * dy);
        }
    }, { passive: false }); // passive:false if we intend to call preventDefault

    canvas.addEventListener('touchmove', (event) => {
        event.preventDefault(); // Prevent default scrolling/zooming during move
        if (event.touches.length === 1 && isPanning) { 
            movePan(event.touches[0].clientX, event.touches[0].clientY);
        } else if (event.touches.length === 2 && pinchStartDistance) {
            const dx = event.touches[0].clientX - event.touches[1].clientX;
            const dy = event.touches[0].clientY - event.touches[1].clientY;
            const currentDistance = Math.sqrt(dx * dx + dy * dy);
            const zoomFactor = currentDistance / pinchStartDistance;

            const rect = canvas.getBoundingClientRect();
            // Use midpoint of touches for zoom center
            const MclientX = (event.touches[0].clientX + event.touches[1].clientX) / 2;
            const MclientY = (event.touches[0].clientY + event.touches[1].clientY) / 2;
            const mouseX = MclientX - rect.left;
            const mouseY = MclientY - rect.top;

            applyZoom(zoomFactor, mouseX, mouseY);
            pinchStartDistance = currentDistance; // Update for next move
        }
    }, { passive: false });

    canvas.addEventListener('touchend', (event) => {
        let wasTapHandled = false;

        // Check for tap on single touch end
        // (event.changedTouches gives the touches that were just removed)
        if (event.changedTouches.length === 1 && touchStartX !== undefined && touchStartTime !== undefined) {
            const touch = event.changedTouches[0];
            const deltaX = touch.clientX - touchStartX;
            const deltaY = touch.clientY - touchStartY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const duration = Date.now() - touchStartTime;

            if (distance < TAP_THRESHOLD && duration < TAP_DURATION_THRESHOLD && !running && typeof cellSize !== 'undefined') {
                // This is a TAP
                event.preventDefault(); // Prevent click event and other default actions

                const rect = canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;

                const col = Math.floor(x / cellSize + viewOffsetX);
                const row = Math.floor(y / cellSize + viewOffsetY);

                if (row >= 0 && row < rows && col >= 0 && col < cols) {
                    grid[row][col] = grid[row][col] ? 0 : 1;
                    if (!running) { // Only update initialGrid if game is not running
                        initialGrid[row][col] = grid[row][col];
                    }
                    drawGrid();
                }
                wasTapHandled = true;
                isPanning = false; // Explicitly stop panning if it was a tap
                canvas.style.cursor = running ? 'grab' : 'crosshair'; // Reset cursor
            }
        }

        // General cleanup for pan and pinch
        if (event.touches.length < 2) { // If less than 2 touches remain
            pinchStartDistance = null;
        }
        if (event.touches.length < 1) { // All fingers are up
            if (!wasTapHandled) {
                // If it wasn't a tap, and panning might have occurred, ensure pan stops
                stopPan();
            }
            // Reset touch start variables for the next interaction
            touchStartX = undefined;
            touchStartY = undefined;
            touchStartTime = undefined;
        }
    });


    // --- Click Handler (Mainly for Desktop, Fallback for Mobile if tap not handled) ---
    canvas.addEventListener('click', (event) => {
      // If running, or cellSize is undefined, or isPanning is true, return.
      // isPanning check is important to prevent click after a drag.
      if (running || typeof cellSize === 'undefined' || isPanning) {
          return;
      }
      
      // The timeout helps to ensure that this click event (which on mobile might fire after touchend)
      // doesn't register if a pan was just completed or a tap was already handled by touchend.
      setTimeout(() => {
        // Re-check isPanning inside the timeout.
        // If a tap was handled by touchend and called preventDefault, this click might not even fire.
        // If it does fire, and it wasn't a pan, isPanning should be false.
        if (isPanning) return;

        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;

        const col = Math.floor(x / cellSize + viewOffsetX);
        const row = Math.floor(y / cellSize + viewOffsetY);

        if (row >= 0 && row < rows && col >= 0 && col < cols) {
          grid[row][col] = grid[row][col] ? 0 : 1;
          if (!running) { // Only update initialGrid if game is not running
            initialGrid[row][col] = grid[row][col];
          }
          drawGrid();
        }
      }, 50); // Small delay to allow tap handling to potentially suppress this
    });

    // --- Drag and Drop for Shapes ---
    canvas.addEventListener('dragover', (event) => {
      event.preventDefault(); // Necessary to allow dropping
    });

    canvas.addEventListener('drop', (event) => {
      event.preventDefault();
      if (typeof cellSize === 'undefined') return; // Ensure cellSize is defined

      const shapeName = event.dataTransfer.getData('text/plain');
      if (!shapeName || !shapes[shapeName]) return; // Invalid shape

      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;

      // Calculate grid cell where the shape's top-left corner will be placed
      const baseCol = Math.floor(x / cellSize + viewOffsetX);
      const baseRow = Math.floor(y / cellSize + viewOffsetY);

      const pattern = shapes[shapeName];
      pattern.forEach(([r, c]) => {
        const row = baseRow + r;
        const col = baseCol + c;
        if (row >= 0 && row < rows && col >= 0 && col < cols) {
          grid[row][col] = 1; // Set cell to alive
          if (!running) { // Update initialGrid if game not running
            initialGrid[row][col] = 1;
          }
        }
      });
      drawGrid();
    });

    // --- Control Button Event Listeners ---
    startStopBtn.addEventListener('click', () => {
      if (!running) {
        running = true;
        startStopBtn.textContent = 'Stop';
        canvas.style.cursor = 'grab'; // Indicate panning is possible while running
        initialGrid = grid.map(rowArray => rowArray.slice()); // Save current state as initial for reset
        runGame();
      } else {
        running = false;
        startStopBtn.textContent = 'Start';
        if (timeoutId) clearTimeout(timeoutId);
        canvas.style.cursor = isPanning ? 'grabbing' : 'crosshair'; // Revert to crosshair if not panning
      }
    });

    resetBtn.addEventListener('click', () => {
      if (running) {
        running = false;
        startStopBtn.textContent = 'Start';
        if (timeoutId) clearTimeout(timeoutId);
      }
      grid = initialGrid.map(rowArray => rowArray.slice()); // Restore from last saved initial state
      drawGrid();
      canvas.style.cursor = 'crosshair';
    });

    randomBtn.addEventListener('click', () => {
      if (running) {
        running = false;
        startStopBtn.textContent = 'Start';
        if (timeoutId) clearTimeout(timeoutId);
      }
      grid = Array.from({ length: rows }, () =>
        Array.from({ length: cols }, () => (Math.random() < 0.3 ? 1 : 0)) // Adjust density here
      );
      initialGrid = grid.map(rowArray => rowArray.slice()); // New random state becomes initial
      drawGrid();
      canvas.style.cursor = 'crosshair';
    });

    clearBtn.addEventListener('click', () => {
      if (running) {
        running = false;
        startStopBtn.textContent = 'Start';
        if (timeoutId) clearTimeout(timeoutId);
      }
      grid = createEmptyGrid();
      initialGrid = createEmptyGrid(); // Empty state becomes initial
      drawGrid();
      canvas.style.cursor = 'crosshair';
    });

    speedRange.addEventListener('input', () => {
      speed = parseInt(speedRange.value, 10);
    });

    // --- Core Game Logic Functions ---
    function createEmptyGrid() {
      return Array.from({ length: rows }, () => Array(cols).fill(0));
    }

    function drawGrid() {
      // Ensure context and dimensions are valid before drawing
      if (!ctx || !canvas.width || !canvas.height || typeof cellSize === 'undefined' || cellSize <= 0) {
        // console.warn("DrawGrid called with invalid state", {ctx, canvasW: canvas.width, canvasH: canvas.height, cellSize});
        return;
      }
      ctx.imageSmoothingEnabled = false; // For crisp pixels
      ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas
      
      ctx.fillStyle = '#00FFFF'; // Color of live cells
      ctx.strokeStyle = '#333'; // Color of grid lines
      // Adjust line width based on cell size for visibility, but keep it thin
      ctx.lineWidth = Math.max(0.1, Math.min(1, cellSize / 10)); 

      // Calculate visible portion of the grid to optimize drawing
      const buffer = 1; // Draw a bit outside the viewport to avoid edge artifacts during panning
      const startCol = Math.floor(viewOffsetX - buffer);
      const endCol = Math.ceil(viewOffsetX + canvas.width / cellSize + buffer);
      const startRow = Math.floor(viewOffsetY - buffer);
      const endRow = Math.ceil(viewOffsetY + canvas.height / cellSize + buffer);

      for (let r = startRow; r < endRow; r++) {
        for (let c = startCol; c < endCol; c++) {
          // Skip cells outside the actual grid boundaries
          if (r < 0 || r >= rows || c < 0 || c >= cols) continue;

          const screenX = (c - viewOffsetX) * cellSize;
          const screenY = (r - viewOffsetY) * cellSize;

          if (grid[r][c]) { // If cell is alive
            // For very small cells, drawing a slightly smaller fill can look better than also drawing a border
            if (cellSize < 3) { 
                ctx.fillRect(screenX + ctx.lineWidth, screenY + ctx.lineWidth, cellSize - (ctx.lineWidth*2), cellSize - (ctx.lineWidth*2));
            } else {
                ctx.fillRect(screenX, screenY, cellSize, cellSize);
            }
          }
          // Draw grid lines if cells are large enough to see them
          if (cellSize > 3) { 
            ctx.strokeRect(screenX, screenY, cellSize, cellSize);
          }
        }
      }
    }

    function getNextGrid() {
      const nextGrid = createEmptyGrid();
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const neighbors = countNeighbors(row, col);
          if (grid[row][col]) { // Cell is alive
            nextGrid[row][col] = (neighbors === 2 || neighbors === 3) ? 1 : 0;
          } else { // Cell is dead
            nextGrid[row][col] = (neighbors === 3) ? 1 : 0;
          }
        }
      }
      return nextGrid;
    }

    function countNeighbors(row, col) {
      let count = 0;
      for (let i = -1; i <= 1; i++) {
        for (let j = -1; j <= 1; j++) {
          if (i === 0 && j === 0) continue; // Skip the cell itself
          // Modulo for toroidal array (wrapping edges)
          const nRow = (row + i + rows) % rows;
          const nCol = (col + j + cols) % cols;
          // Check if neighbor exists and is alive
          if (grid[nRow] && typeof grid[nRow][nCol] !== 'undefined') {
             count += grid[nRow][nCol];
          }
        }
      }
      return count;
    }

    function runGame() {
      if (!running) return;
      grid = getNextGrid();
      drawGrid();
      // Use requestAnimationFrame for smoother animations synced with display refresh
      timeoutId = setTimeout(() => {
        requestAnimationFrame(runGame);
      }, 1000 / speed); // Adjust speed via timeout
    }
  </script>
</body>
</html>
