<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Conway's Game of Life - Mobile Optimized</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background-color: #121212;
      display: flex;
      flex-direction: column; /* Main axis is vertical now */
      color: #fff;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      overflow: hidden;
      position: fixed;
    }

    #main {
      flex-grow: 1; /* Takes up available space above the bottom sidebar */
      display: flex;
      flex-direction: column;
      box-sizing: border-box;
      overflow: hidden;
      position: relative; 
    }

    #sidebar {
      width: 100%; 
      height: 200px; 
      background-color: #1e1e1e;
      border-top: 2px solid #333; 
      display: flex;
      flex-direction: column; 
      box-sizing: border-box;
      transition: height 0.3s ease; 
      flex-shrink: 0; 
      z-index: 100;
    }

    #sidebar.collapsed {
      height: 45px; 
    }

    #toggleSidebarBtn {
      font-size: 1.5rem;
      text-align: center;
      background-color: #1e1e1e;
      border: none;
      cursor: pointer;
      color: #fff;
      padding: 8px 0; 
      width: 100%;
      box-sizing: border-box;
      flex-shrink: 0;
      transition: background-color 0.2s;
      -webkit-tap-highlight-color: transparent;
    }

    #toggleSidebarBtn:hover, #toggleSidebarBtn:active {
      background-color: #333;
      color: #00FFFF;
    }

    #sidebar h2 {
      margin: 5px 10px; 
      font-size: 1rem; 
      text-align: center;
      padding-bottom: 5px;
      flex-shrink: 0;
    }

    #sidebar.collapsed h2 {
      display: none;
    }

    #shapePalette {
      display: flex;
      flex-direction: row; 
      gap: 15px;
      padding: 10px;
      box-sizing: border-box;
      overflow-x: auto; 
      overflow-y: hidden;
      flex-grow: 1; 
      -webkit-overflow-scrolling: touch;
      align-items: center; 
    }

    #sidebar.collapsed #shapePalette {
      display: none;
    }

    .shape-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      font-size: 0.8rem;
      flex-shrink: 0; 
    }

    .shapeCanvas {
      border: 1px solid #333;
      background-color: #161616;
      cursor: grab;
      width: 70px;
      height: 70px;
    }

    h1 {
      margin: 10px 0;
      font-size: 1.8rem;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
      align-self: center;
      text-align: center;
    }

    #controls {
      margin: 10px 0;
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 0 10px;
      box-sizing: border-box;
      align-items: center;
    }

    .control-row {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      justify-content: center;
      width: 100%;
    }
    .control-row.multi-item {
      flex-direction: row;
      justify-content: space-around;
    }

    #controls button, #controls input[type="range"], #controls label {
      padding: 10px 15px;
      background-color: #1e1e1e;
      border: none;
      border-radius: 8px;
      color: #fff;
      cursor: pointer;
      transition: background-color 0.2s;
      font-size: 0.9rem;
      -webkit-tap-highlight-color: transparent;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    #controls button {
      min-width: 120px;
      text-align: center;
    }

    #controls button:hover, #controls input[type="range"]:hover,
    #controls button:active, #controls input[type="range"]:active {
      background-color: #333;
    }

    #controls input[type="range"] {
      width: 70%;
      max-width: 200px;
      padding: 5px 0;
    }
    #controls label {
      background-color: transparent;
      box-shadow: none;
      padding: 5px;
    }

    #canvasContainer {
      flex-grow: 1; 
      display: flex;
      justify-content: center;
      align-items: center;
      box-sizing: border-box;
      position: relative; 
      padding: 5px;
      min-height: 0; 
      overflow: hidden;
      touch-action: none;
    }

    #gameCanvas {
      border: 1px solid #444;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.15);
      background-color: #1e1e1e;
      cursor: crosshair;
      display: block;
      image-rendering: pixelated;
      image-rendering: -moz-crisp-edges;
      image-rendering: crisp-edges;
    }

    @media (min-width: 768px) {
      #sidebar {
        height: 220px; 
      }
      #sidebar.collapsed {
        height: 45px; 
      }
      #sidebar h2 {
        font-size: 1.1rem;
        margin: 8px 15px;
      }
      #shapePalette {
        padding: 15px;
      }
      h1 {
        font-size: 2rem;
      }
      #controls {
        flex-direction: row;
        justify-content: center;
        gap: 15px;
        padding: 0 20px;
      }
      .control-row {
        flex-direction: row;
        width: auto;
      }
      #controls button {
        min-width: auto;
      }
      #controls input[type="range"] {
        width: 150px;
      }
      #canvasContainer {
        padding: 10px;
      }
    }

    @media (max-width: 360px) {
      h1 {
        font-size: 1.5rem;
      }
      #controls button {
        padding: 8px 10px;
        font-size: 0.8rem;
      }
      .shapeCanvas {
        width: 60px;
        height: 60px;
      }
       #sidebar {
        height: 180px; 
      }
    }
  </style>
</head>
<body>
  <div id="main">
    <h1>Conway's Game of Life</h1>
    <div id="controls">
      <div class="control-row">
        <button id="startStopBtn">Start</button>
        <button id="resetBtn">Reset</button>
      </div>
      <div class="control-row">
        <label for="speedRange">Speed:</label>
        <input type="range" id="speedRange" min="1" max="20" value="10">
      </div>
      <div class="control-row multi-item">
        <button id="randomBtn">Randomize</button>
        <button id="clearBtn">Clear</button>
      </div>
    </div>
    <div id="canvasContainer">
      <canvas id="gameCanvas"></canvas>
    </div>
  </div>

  <div id="sidebar">
    <button id="toggleSidebarBtn">â–¼</button> 
    <h2>Shapes</h2>
    <div id="shapePalette">
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const rows = 80; 
    const cols = 80;
    let cellSize;
    let grid = createEmptyGrid();
    let running = false;
    let timeoutId = null;
    let speed = 10;
    let initialGrid = createEmptyGrid();

    const startStopBtn = document.getElementById('startStopBtn');
    const resetBtn = document.getElementById('resetBtn');
    const randomBtn = document.getElementById('randomBtn');
    const clearBtn = document.getElementById('clearBtn');
    const speedRange = document.getElementById('speedRange');
    const shapePalette = document.getElementById('shapePalette');
    const canvasContainer = document.getElementById('canvasContainer');
    const sidebar = document.getElementById('sidebar');
    const toggleSidebarBtn = document.getElementById('toggleSidebarBtn');

    let viewOffsetX = 0;
    let viewOffsetY = 0;
    let isPanning = false;
    let lastPanX, lastPanY;

    const MIN_CELL_SIZE_DESKTOP = 2;
    const MIN_CELL_SIZE_MOBILE = 4;
    let currentMinCellSize = window.innerWidth < 768 ? MIN_CELL_SIZE_MOBILE : MIN_CELL_SIZE_DESKTOP;
    const MAX_CELL_SIZE = 100;
    let initialCellSizeSetup = true;

    let pinchStartDistance = null;

    // Variables for tap detection
    let touchStartX, touchStartY, touchStartTime;
    const TAP_THRESHOLD = 10; // Max distance in pixels for a touch to be considered a tap
    const TAP_DURATION_THRESHOLD = 250; // Max duration in ms for a touch to be considered a tap (increased slightly)


    const shapes = {
      Glider: [[0,1],[1,2],[2,0],[2,1],[2,2]],
      Blinker: [[0,0],[0,1],[0,2]],
      Toad: [[0,1],[0,2],[0,3],[1,0],[1,1],[1,2]],
      Beacon: [[0,0],[0,1],[1,0],[1,1],[2,2],[2,3],[3,2],[3,3]],
      Block: [[0,0],[0,1],[1,0],[1,1]],
      Beehive: [[0,1],[0,2],[1,0],[1,3],[2,1],[2,2]],
      Loaf: [[0,1],[0,2],[1,0],[1,3],[2,1],[2,4],[3,2],[3,3]],
      Boat: [[0,0],[0,1],[1,0],[1,2],[2,1]],
      Tub: [[0,1],[1,0],[1,2],[2,1]],
      Rpento: [[0,1],[0,2],[1,0],[1,1],[2,1]],
      Diehard: [[0,6],[1,0],[1,1],[2,1],[2,5],[2,6],[2,7]],
      Acorn: [[0,1],[1,3],[2,0],[2,1],[2,4],[2,5],[2,6]]
    };
    const previewSize = 70;

    function createShapePreviews() {
      shapePalette.innerHTML = ''; // Clear existing previews
      for (let [name, pattern] of Object.entries(shapes)) {
        const container = document.createElement('div');
        container.classList.add('shape-container');
        const label = document.createElement('div');
        label.textContent = name;
        label.style.marginBottom = '5px';
        const shapeCanvasEl = document.createElement('canvas'); // Renamed to avoid conflict with global 'canvas'
        shapeCanvasEl.width = previewSize;
        shapeCanvasEl.height = previewSize;
        shapeCanvasEl.classList.add('shapeCanvas');
        shapeCanvasEl.draggable = true;
        shapeCanvasEl.dataset.shape = name;
        const sCtx = shapeCanvasEl.getContext('2d');
        sCtx.fillStyle = '#161616';
        sCtx.fillRect(0, 0, previewSize, previewSize);
        let maxRow = 0, maxCol = 0;
        pattern.forEach(([r, c]) => {
          if (r > maxRow) maxRow = r;
          if (c > maxCol) maxCol = c;
        });
        const rowsUsed = maxRow + 1;
        const colsUsed = maxCol + 1;
        const previewCellSize = Math.max(1, Math.floor(previewSize / Math.max(rowsUsed, colsUsed, 1)));
        const offsetX = (previewSize - colsUsed * previewCellSize) / 2;
        const offsetY = (previewSize - rowsUsed * previewCellSize) / 2;
        sCtx.fillStyle = '#00FFFF';
        pattern.forEach(([r, c]) => {
          sCtx.fillRect(offsetX + c * previewCellSize, offsetY + r * previewCellSize, previewCellSize -0.5, previewCellSize -0.5);
        });
        sCtx.strokeStyle = '#333';
        sCtx.lineWidth = 0.5;
        if (previewCellSize > 3) {
          for (let i = 0; i < rowsUsed; i++) {
            for (let j = 0; j < colsUsed; j++) {
              sCtx.strokeRect(offsetX + j * previewCellSize, offsetY + i * previewCellSize, previewCellSize, previewCellSize);
            }
          }
        }
        shapeCanvasEl.addEventListener('dragstart', (event) => {
          event.dataTransfer.setData('text/plain', name);
        });
        container.appendChild(label);
        container.appendChild(shapeCanvasEl);
        shapePalette.appendChild(container);
      }
    }

    function resizeCanvas() {
      currentMinCellSize = window.innerWidth < 768 ? MIN_CELL_SIZE_MOBILE : MIN_CELL_SIZE_DESKTOP;
      if (!canvasContainer.clientWidth || !canvasContainer.clientHeight) {
        requestAnimationFrame(resizeCanvas);
        return;
      }
      const containerWidth = canvasContainer.clientWidth;
      const containerHeight = canvasContainer.clientHeight;
      if (containerWidth <= 0 || containerHeight <= 0) return;

      const oldCanvasWidth = canvas.width;
      const oldCanvasHeight = canvas.height;
      let centerXGrid = viewOffsetX + (oldCanvasWidth / 2 / (cellSize || currentMinCellSize));
      let centerYGrid = viewOffsetY + (oldCanvasHeight / 2 / (cellSize || currentMinCellSize));

      canvas.width = containerWidth;
      canvas.height = containerHeight;
      ctx.imageSmoothingEnabled = false;

      if (initialCellSizeSetup) {
        let initialFitCellSize = Math.floor(Math.min(containerWidth / cols, containerHeight / rows));
        if (window.innerWidth < 768) {
            initialFitCellSize = Math.floor(Math.min(containerWidth / (cols/1.5), containerHeight / (rows/1.5)));
        }
        cellSize = Math.max(currentMinCellSize, initialFitCellSize);
        viewOffsetX = (cols - containerWidth / cellSize) / 2;
        viewOffsetY = (rows - containerHeight / cellSize) / 2;
        initialCellSizeSetup = false;
      } else {
        if (cellSize > 0) {
          viewOffsetX = centerXGrid - (canvas.width / 2 / cellSize);
          viewOffsetY = centerYGrid - (canvas.height / 2 / cellSize);
        } else {
          cellSize = currentMinCellSize;
          viewOffsetX = (cols - containerWidth / cellSize) / 2;
          viewOffsetY = (rows - containerHeight / cellSize) / 2;
        }
      }
      clampViewOffset();
      drawGrid();
    }

    function clampViewOffset() {
      if (typeof cellSize === 'undefined' || cellSize <= 0) return;
      if (!canvas.width || !canvas.height) return;

      if (cols * cellSize < canvas.width) {
        viewOffsetX = (cols * cellSize - canvas.width) / (2 * cellSize);
      } else {
        const minX = 0;
        const maxX = Math.max(0, cols - (canvas.width / cellSize));
        viewOffsetX = Math.max(minX, Math.min(viewOffsetX, maxX));
      }
      if (rows * cellSize < canvas.height) {
        viewOffsetY = (rows * cellSize - canvas.height) / (2 * cellSize);
      } else {
        const minY = 0;
        const maxY = Math.max(0, rows - (canvas.height / cellSize));
        viewOffsetY = Math.max(minY, Math.min(viewOffsetY, maxY));
      }
    }

    window.addEventListener('resize', resizeCanvas);
    setTimeout(resizeCanvas, 100);

    toggleSidebarBtn.addEventListener('click', () => {
      sidebar.classList.toggle('collapsed');
      toggleSidebarBtn.textContent = sidebar.classList.contains('collapsed') ? 'â–²' : 'â–¼';
      setTimeout(resizeCanvas, 310); 
    });

    createShapePreviews();

    function applyZoom(zoomFactor, mouseX, mouseY) {
        if (typeof cellSize === 'undefined') return;
        const mouseGridX_before = (mouseX / cellSize) + viewOffsetX;
        const mouseGridY_before = (mouseY / cellSize) + viewOffsetY;
        let newCellSize = cellSize * zoomFactor;
        newCellSize = Math.max(currentMinCellSize, Math.min(MAX_CELL_SIZE, newCellSize));
        if (newCellSize === cellSize) return;
        cellSize = newCellSize;
        viewOffsetX = mouseGridX_before - (mouseX / cellSize);
        viewOffsetY = mouseGridY_before - (mouseY / cellSize);
        clampViewOffset();
        drawGrid();
    }

    canvas.addEventListener('wheel', (event) => {
      event.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;
      const zoomFactor = event.deltaY < 0 ? 1.1 : 0.9;
      applyZoom(zoomFactor, mouseX, mouseY);
    }, { passive: false });

    function startPan(clientX, clientY) {
        isPanning = true;
        lastPanX = clientX;
        lastPanY = clientY;
        canvas.style.cursor = 'grabbing';
    }

    function movePan(clientX, clientY) {
        if (!isPanning || typeof cellSize === 'undefined' || cellSize <= 0) return;
        const dx = clientX - lastPanX;
        const dy = clientY - lastPanY;
        viewOffsetX -= dx / cellSize;
        viewOffsetY -= dy / cellSize;
        lastPanX = clientX;
        lastPanY = clientY;
        clampViewOffset();
        drawGrid();
    }

    function stopPan() {
        if (isPanning) {
            isPanning = false;
            canvas.style.cursor = running ? 'grab' : 'crosshair';
        }
        pinchStartDistance = null; 
    }

    // --- Mouse Panning ---
    canvas.addEventListener('mousedown', (event) => {
      if (event.button !== 0) return; 
      if (event.target !== canvas) return;
      // Do not start pan if a shape is being dragged from palette
      if (event.target.classList.contains('shapeCanvas')) return;
      startPan(event.clientX, event.clientY);
    });
    canvas.addEventListener('mousemove', (event) => {
      movePan(event.clientX, event.clientY);
    });
    window.addEventListener('mouseup', stopPan); 
    canvas.addEventListener('mouseleave', stopPan);


    // --- Touch Panning, Pinch Zoom, and Tap ---
    canvas.addEventListener('touchstart', (event) => {
        // event.preventDefault(); // Already have touch-action: none on container, might not be needed here or could interfere with drop.
                               // Let's test without it first for canvas specific interactions.
                               // If issues with page scroll, add it back.
                               // For tap, preventDefault will be called if tap is handled.
        if (event.touches.length === 1) {
            const touch = event.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchStartTime = Date.now();
            // We call startPan, but a very short touch will be treated as a tap in touchend
            startPan(touch.clientX, touch.clientY);
        } else if (event.touches.length === 2) {
            isPanning = false; // Stop single-touch panning if two fingers are down
            const dx = event.touches[0].clientX - event.touches[1].clientX;
            const dy = event.touches[0].clientY - event.touches[1].clientY;
            pinchStartDistance = Math.sqrt(dx * dx + dy * dy);
        }
    }, { passive: false }); // passive:false if we intend to call preventDefault

    canvas.addEventListener('touchmove', (event) => {
        event.preventDefault(); // Prevent default scrolling/zooming during move
        if (event.touches.length === 1 && isPanning) { 
            movePan(event.touches[0].clientX, event.touches[0].clientY);
        } else if (event.touches.length === 2 && pinchStartDistance) {
            const dx = event.touches[0].clientX - event.touches[1].clientX;
            const dy = event.touches[0].clientY - event.touches[1].clientY;
            const currentDistance = Math.sqrt(dx * dx + dy * dy);
            const zoomFactor = currentDistance / pinchStartDistance;
            const rect = canvas.getBoundingClientRect();
            const MclientX = (event.touches[0].clientX + event.touches[1].clientX) / 2;
            const MclientY = (event.touches[0].clientY + event.touches[1].clientY) / 2;
            const mouseX = MclientX - rect.left;
            const mouseY = MclientY - rect.top;
            applyZoom(zoomFactor, mouseX, mouseY);
            pinchStartDistance = currentDistance; 
        }
    }, { passive: false });

    canvas.addEventListener('touchend', (event) => {
        let wasTapHandled = false;

        // Check for tap on single touch end
        if (event.changedTouches.length === 1 && touchStartX !== undefined && touchStartTime !== undefined) {
            const touch = event.changedTouches[0];
            const deltaX = touch.clientX - touchStartX;
            const deltaY = touch.clientY - touchStartY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const duration = Date.now() - touchStartTime;

            if (distance < TAP_THRESHOLD && duration < TAP_DURATION_THRESHOLD && !running && typeof cellSize !== 'undefined') {
                // This is a TAP
                event.preventDefault(); // Prevent click event and other default actions

                const rect = canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;

                const col = Math.floor(x / cellSize + viewOffsetX);
                const row = Math.floor(y / cellSize + viewOffsetY);

                if (row >= 0 && row < rows && col >= 0 && col < cols) {
                    grid[row][col] = grid[row][col] ? 0 : 1;
                    if (!running) { // Only update initialGrid if game is not running
                        initialGrid[row][col] = grid[row][col];
                    }
                    drawGrid();
                }
                wasTapHandled = true;
                isPanning = false; // Explicitly stop panning if it was a tap
                canvas.style.cursor = running ? 'grab' : 'crosshair'; // Reset cursor
            }
        }

        // General cleanup for pan and pinch
        if (event.touches.length < 2) {
            pinchStartDistance = null;
        }
        if (event.touches.length < 1) { // All fingers are up
            if (!wasTapHandled) {
                // If it wasn't a tap, and panning might have occurred
                stopPan();
            }
            // Reset touch start variables for the next interaction
            touchStartX = undefined;
            touchStartY = undefined;
            touchStartTime = undefined;
        }
    });


    // --- Click Handler (Mainly for Desktop, Fallback for Mobile) ---
    canvas.addEventListener('click', (event) => {
      // If running, or cellSize is undefined, or isPanning is true, return.
      // isPanning check is important to prevent click after a drag.
      if (running || typeof cellSize === 'undefined' || isPanning) {
          return;
      }
      
      // The timeout helps to ensure that this click event (which on mobile might fire after touchend)
      // doesn't register if a pan was just completed or a tap was already handled by touchend.
      setTimeout(() => {
        // Re-check isPanning inside the timeout.
        // If a tap was handled by touchend and called preventDefault, this click might not even fire.
        // If it does fire, and it wasn't a pan, isPanning should be false.
        if (isPanning) return;

        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;

        const col = Math.floor(x / cellSize + viewOffsetX);
        const row = Math.floor(y / cellSize + viewOffsetY);

        if (row >= 0 && row < rows && col >= 0 && col < cols) {
          grid[row][col] = grid[row][col] ? 0 : 1;
          if (!running) { // Only update initialGrid if game is not running
            initialGrid[row][col] = grid[row][col];
          }
          drawGrid();
        }
      }, 50); // Small delay
    });

    // --- Drag and Drop for Shapes ---
    canvas.addEventListener('dragover', (event) => {
      event.preventDefault(); // Necessary to allow dropping
    });

    canvas.addEventListener('drop', (event) => {
      event.preventDefault();
      if (typeof cellSize === 'undefined') return;
      const shapeName = event.dataTransfer.getData('text/plain');
      if (!shapeName || !shapes[shapeName]) return;
      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      const baseCol = Math.floor(x / cellSize + viewOffsetX);
      const baseRow = Math.floor(y / cellSize + viewOffsetY);
      const pattern = shapes[shapeName];
      pattern.forEach(([r, c]) => {
        const row = baseRow + r;
        const col = baseCol + c;
        if (row >= 0 && row < rows && col >= 0 && col < cols) {
          grid[row][col] = 1;
          if (!running) { // Update initialGrid if game not running
            initialGrid[row][col] = 1;
          }
        }
      });
      drawGrid();
    });

    // --- Control Button Event Listeners ---
    startStopBtn.addEventListener('click', () => {
      if (!running) {
        running = true;
        startStopBtn.textContent = 'Stop';
        canvas.style.cursor = 'grab'; // Indicate panning is possible while running
        initialGrid = grid.map(rowArray => rowArray.slice()); // Save current state as initial for reset
        runGame();
      } else {
        running = false;
        startStopBtn.textContent = 'Start';
        if (timeoutId) clearTimeout(timeoutId);
        canvas.style.cursor = isPanning ? 'grabbing' : 'crosshair'; // Revert to crosshair if not panning
      }
    });

    resetBtn.addEventListener('click', () => {
      if (running) {
        running = false;
        startStopBtn.textContent = 'Start';
        if (timeoutId) clearTimeout(timeoutId);
      }
      grid = initialGrid.map(rowArray => rowArray.slice()); // Restore from last saved initial state
      drawGrid();
      canvas.style.cursor = 'crosshair';
    });

    randomBtn.addEventListener('click', () => {
      if (running) {
        running = false;
        startStopBtn.textContent = 'Start';
        if (timeoutId) clearTimeout(timeoutId);
      }
      grid = Array.from({ length: rows }, () =>
        Array.from({ length: cols }, () => (Math.random() < 0.3 ? 1 : 0))
      );
      initialGrid = grid.map(rowArray => rowArray.slice()); // New random state becomes initial
      drawGrid();
      canvas.style.cursor = 'crosshair';
    });

    clearBtn.addEventListener('click', () => {
      if (running) {
        running = false;
        startStopBtn.textContent = 'Start';
        if (timeoutId) clearTimeout(timeoutId);
      }
      grid = createEmptyGrid();
      initialGrid = createEmptyGrid(); // Empty state becomes initial
      drawGrid();
      canvas.style.cursor = 'crosshair';
    });

    speedRange.addEventListener('input', () => {
      speed = parseInt(speedRange.value, 10);
    });

    // --- Core Game Logic Functions ---
    function createEmptyGrid() {
      return Array.from({ length: rows }, () => Array(cols).fill(0));
    }

    function drawGrid() {
      if (!ctx || !canvas.width || !canvas.height || typeof cellSize === 'undefined' || cellSize <= 0) {
        return;
      }
      ctx.imageSmoothingEnabled = false;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#00FFFF';
      ctx.strokeStyle = '#333';
      ctx.lineWidth = Math.max(0.1, Math.min(1, cellSize / 10));

      const buffer = 1;
      const startCol = Math.floor(viewOffsetX - buffer);
      const endCol = Math.ceil(viewOffsetX + canvas.width / cellSize + buffer);
      const startRow = Math.floor(viewOffsetY - buffer);
      const endRow = Math.ceil(viewOffsetY + canvas.height / cellSize + buffer);

      for (let r = startRow; r < endRow; r++) {
        for (let c = startCol; c < endCol; c++) {
          if (r < 0 || r >= rows || c < 0 || c >= cols) continue;
          const screenX = (c - viewOffsetX) * cellSize;
          const screenY = (r - viewOffsetY) * cellSize;
          if (grid[r][c]) {
            if (cellSize < 3) {
                ctx.fillRect(screenX + ctx.lineWidth, screenY + ctx.lineWidth, cellSize - (ctx.lineWidth*2), cellSize - (ctx.lineWidth*2));
            } else {
                ctx.fillRect(screenX, screenY, cellSize, cellSize);
            }
          }
          if (cellSize > 3) {
            ctx.strokeRect(screenX, screenY, cellSize, cellSize);
          }
        }
      }
    }

    function getNextGrid() {
      const nextGrid = createEmptyGrid();
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const neighbors = countNeighbors(row, col);
          if (grid[row][col]) {
            nextGrid[row][col] = (neighbors === 2 || neighbors === 3) ? 1 : 0;
          } else {
            nextGrid[row][col] = (neighbors === 3) ? 1 : 0;
          }
        }
      }
      return nextGrid;
    }

    function countNeighbors(row, col) {
      let count = 0;
      for (let i = -1; i <= 1; i++) {
        for (let j = -1; j <= 1; j++) {
          if (i === 0 && j === 0) continue;
          const nRow = (row + i + rows) % rows;
          const nCol = (col + j + cols) % cols;
          if (grid[nRow] && typeof grid[nRow][nCol] !== 'undefined') {
            count += grid[nRow][nCol];
          }
        }
      }
      return count;
    }

    function runGame() {
      if (!running) return;
      grid = getNextGrid();
      drawGrid();
      timeoutId = setTimeout(() => {
        requestAnimationFrame(runGame);
      }, 1000 / speed);
    }
  </script>
</body>
</html>
