<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Conway's Game of Life - Mobile Optimized</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%; /* Changed from 100vw to 100% for better compatibility */
      height: 100%; /* Changed from 100vh to 100% */
      background-color: #121212;
      display: flex;
      color: #fff;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      overflow: hidden; /* Prevent body scrollbars */
      position: fixed; /* Prevents pull-to-refresh issues on mobile */
    }

    #sidebar {
      width: 250px; /* Default open width */
      background-color: #1e1e1e;
      border-right: 2px solid #333;
      display: flex;
      flex-direction: column;
      height: 100%;
      box-sizing: border-box;
      transition: width 0.3s ease, transform 0.3s ease; /* Added transform for potential off-screen */
      flex-shrink: 0;
      z-index: 100; /* Ensure sidebar is above canvas if it ever overlaps */
    }

    #sidebar.collapsed {
      width: 45px;
    }

    #toggleSidebarBtn {
      font-size: 1.5rem;
      text-align: center;
      background-color: #1e1e1e;
      border: none;
      border-bottom: 1px solid #333;
      cursor: pointer;
      color: #fff;
      padding: 10px 0; /* Increased padding for better touch target */
      width: 100%;
      box-sizing: border-box;
      flex-shrink: 0;
      transition: background-color 0.2s;
      -webkit-tap-highlight-color: transparent; /* Remove tap highlight on mobile */
    }

    #toggleSidebarBtn:hover, #toggleSidebarBtn:active {
      background-color: #333;
      color: #00FFFF;
    }

    #sidebar h2 {
      margin: 10px;
      font-size: 1.2rem;
      text-align: center;
      border-bottom: 1px solid #333;
      padding-bottom: 5px;
      flex-shrink: 0;
    }

    #sidebar.collapsed h2 {
      display: none;
    }

    #shapePalette {
      display: flex;
      flex-direction: column;
      gap: 15px;
      padding: 10px;
      box-sizing: border-box;
      overflow-y: auto;
      flex-grow: 1;
      -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
    }

    #sidebar.collapsed #shapePalette {
      display: none;
    }

    .shape-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      font-size: 0.8rem;
    }

    .shapeCanvas {
      border: 1px solid #333;
      background-color: #161616;
      cursor: grab;
      width: 70px; /* Slightly smaller for mobile */
      height: 70px;
    }

    #main {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      height: 100%;
      box-sizing: border-box;
      overflow: hidden;
    }

    h1 {
      margin: 10px 0;
      font-size: 1.8rem; /* Slightly smaller for mobile */
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
      align-self: center;
      text-align: center; /* Ensure it's centered if text wraps */
    }

    #controls {
      margin: 10px 0;
      display: flex;
      flex-direction: column; /* Default to column for mobile-first approach */
      gap: 8px; /* Reduced gap for mobile */
      padding: 0 10px;
      box-sizing: border-box;
      align-items: center;
    }

    .control-row {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap; /* Allow wrapping */
      justify-content: center;
      width: 100%; /* Make rows take full width in column layout */
    }
     /* Specific styling for rows with multiple items to arrange them side-by-side if space allows */
    .control-row.multi-item {
        flex-direction: row;
        justify-content: space-around; /* Distribute items */
    }


    #controls button, #controls input[type="range"], #controls label {
      padding: 10px 15px; /* Larger touch targets */
      background-color: #1e1e1e;
      border: none;
      border-radius: 8px; /* More rounded */
      color: #fff;
      cursor: pointer;
      transition: background-color 0.2s;
      font-size: 0.9rem; /* Readable font size */
      -webkit-tap-highlight-color: transparent;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2); /* Subtle shadow for depth */
    }
     #controls button {
        min-width: 120px; /* Ensure buttons have a decent width */
        text-align: center;
    }


    #controls button:hover, #controls input[type="range"]:hover,
    #controls button:active, #controls input[type="range"]:active {
      background-color: #333;
    }

    #controls input[type="range"] {
      width: 70%; /* Make slider wider on mobile */
      max-width: 200px; /* But not too wide */
      padding: 5px 0; /* Vertical padding for slider track */
    }
    #controls label {
        background-color: transparent; /* Labels don't need background */
        box-shadow: none;
        padding: 5px;
    }


    #canvasContainer {
      flex-grow: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      box-sizing: border-box;
      position: relative;
      padding: 5px; /* Reduced padding for mobile */
      min-height: 0;
      overflow: hidden;
      touch-action: none; /* Prevent default touch actions like page scroll/zoom on canvas */
    }

    #gameCanvas {
      border: 1px solid #444; /* Slightly lighter border */
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.15);
      background-color: #1e1e1e;
      cursor: crosshair;
      display: block;
      image-rendering: pixelated; /* Helps make sharp pixels when scaled */
      image-rendering: -moz-crisp-edges;
      image-rendering: crisp-edges;
    }

    /* Media Queries for larger screens (Desktop) */
    @media (min-width: 768px) {
      #sidebar {
        width: 250px;
      }
      #sidebar.collapsed {
        width: 45px;
      }
      h1 {
        font-size: 2rem;
      }
      #controls {
        flex-direction: row; /* Horizontal controls on desktop */
        justify-content: center;
        gap: 15px;
        padding: 0 20px;
      }
      .control-row {
        flex-direction: row; /* Ensure rows are rows on desktop */
        width: auto; /* Allow rows to size based on content */
      }
      #controls button {
        min-width: auto; /* Reset min-width */
      }
      #controls input[type="range"] {
        width: 150px;
      }
       #canvasContainer {
         padding: 10px;
       }
    }

    /* Specific adjustments for very small screens if needed */
    @media (max-width: 360px) {
        h1 {
            font-size: 1.5rem;
        }
        #controls button {
            padding: 8px 10px;
            font-size: 0.8rem;
        }
        .shapeCanvas {
            width: 60px;
            height: 60px;
        }
    }

  </style>
</head>
<body>
  <div id="sidebar">
    <button id="toggleSidebarBtn">â—€</button>
    <h2>Shapes</h2>
    <div id="shapePalette">
      </div>
  </div>

  <div id="main">
    <h1>Conway's Game of Life</h1>
    <div id="controls">
      <div class="control-row">
        <button id="startStopBtn">Start</button>
        <button id="resetBtn">Reset</button>
      </div>
      <div class="control-row">
        <label for="speedRange">Speed:</label>
        <input type="range" id="speedRange" min="1" max="20" value="10">
      </div>
      <div class="control-row multi-item"> <button id="randomBtn">Randomize</button>
        <button id="clearBtn">Clear</button>
      </div>
    </div>
    <div id="canvasContainer">
      <canvas id="gameCanvas"></canvas>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const rows = 80;
    const cols = 80;
    let cellSize;
    let grid = createEmptyGrid();
    let running = false;
    let timeoutId = null;
    let speed = 10;
    let initialGrid = createEmptyGrid();

    const startStopBtn = document.getElementById('startStopBtn');
    const resetBtn = document.getElementById('resetBtn');
    const randomBtn = document.getElementById('randomBtn');
    const clearBtn = document.getElementById('clearBtn');
    const speedRange = document.getElementById('speedRange');
    const shapePalette = document.getElementById('shapePalette');
    const canvasContainer = document.getElementById('canvasContainer');
    const sidebar = document.getElementById('sidebar');
    const toggleSidebarBtn = document.getElementById('toggleSidebarBtn');

    let viewOffsetX = 0;
    let viewOffsetY = 0;
    let isPanning = false;
    let lastPanX, lastPanY;

    // Adjusted MIN_CELL_SIZE for better visibility, especially on mobile.
    // MAX_CELL_SIZE can also be adjusted if needed.
    const MIN_CELL_SIZE_DESKTOP = 2;
    const MIN_CELL_SIZE_MOBILE = 4; // Larger minimum for mobile
    let currentMinCellSize = window.innerWidth < 768 ? MIN_CELL_SIZE_MOBILE : MIN_CELL_SIZE_DESKTOP;
    const MAX_CELL_SIZE = 100;
    let initialCellSizeSetup = true;

    // Touch state for pinch-zoom (basic implementation)
    let pinchStartDistance = null;


    const shapes = {
      Glider: [[0,1],[1,2],[2,0],[2,1],[2,2]],
      Blinker: [[0,0],[0,1],[0,2]],
      Toad: [[0,1],[0,2],[0,3],[1,0],[1,1],[1,2]],
      Beacon: [[0,0],[0,1],[1,0],[1,1],[2,2],[2,3],[3,2],[3,3]],
      Block: [[0,0],[0,1],[1,0],[1,1]],
      Beehive: [[0,1],[0,2],[1,0],[1,3],[2,1],[2,2]],
      Loaf: [[0,1],[0,2],[1,0],[1,3],[2,1],[2,4],[3,2],[3,3]],
      Boat: [[0,0],[0,1],[1,0],[1,2],[2,1]],
      Tub: [[0,1],[1,0],[1,2],[2,1]],
      Rpento: [[0,1],[0,2],[1,0],[1,1],[2,1]],
      Diehard: [[0,6],[1,0],[1,1],[2,1],[2,5],[2,6],[2,7]],
      Acorn: [[0,1],[1,3],[2,0],[2,1],[2,4],[2,5],[2,6]]
    };
    const previewSize = 70; // Matched .shapeCanvas CSS

    function createShapePreviews() {
      shapePalette.innerHTML = '';
      for (let [name, pattern] of Object.entries(shapes)) {
        const container = document.createElement('div');
        container.classList.add('shape-container');
        const label = document.createElement('div');
        label.textContent = name;
        label.style.marginBottom = '5px';
        const shapeCanvas = document.createElement('canvas');
        shapeCanvas.width = previewSize;
        shapeCanvas.height = previewSize;
        shapeCanvas.classList.add('shapeCanvas');
        shapeCanvas.draggable = true;
        shapeCanvas.dataset.shape = name;
        const sCtx = shapeCanvas.getContext('2d');
        sCtx.fillStyle = '#161616'; // Match CSS
        sCtx.fillRect(0, 0, previewSize, previewSize);
        let maxRow = 0, maxCol = 0;
        pattern.forEach(([r, c]) => {
          if (r > maxRow) maxRow = r;
          if (c > maxCol) maxCol = c;
        });
        const rowsUsed = maxRow + 1;
        const colsUsed = maxCol + 1;
        // Ensure previewCellSize is at least 1 to avoid drawing issues
        const previewCellSize = Math.max(1, Math.floor(previewSize / Math.max(rowsUsed, colsUsed, 1)));
        const offsetX = (previewSize - colsUsed * previewCellSize) / 2;
        const offsetY = (previewSize - rowsUsed * previewCellSize) / 2;
        sCtx.fillStyle = '#00FFFF';
        pattern.forEach(([r, c]) => {
          sCtx.fillRect(offsetX + c * previewCellSize, offsetY + r * previewCellSize, previewCellSize -0.5, previewCellSize -0.5); // Add small gap
        });
        sCtx.strokeStyle = '#333';
        sCtx.lineWidth = 0.5;
        if (previewCellSize > 3) { // Only draw grid if cells are somewhat visible
            for (let i = 0; i < rowsUsed; i++) {
                for (let j = 0; j < colsUsed; j++) {
                    sCtx.strokeRect(offsetX + j * previewCellSize, offsetY + i * previewCellSize, previewCellSize, previewCellSize);
                }
            }
        }
        shapeCanvas.addEventListener('dragstart', (event) => {
          event.dataTransfer.setData('text/plain', name);
        });
        container.appendChild(label);
        container.appendChild(shapeCanvas);
        shapePalette.appendChild(container);
      }
    }

    function resizeCanvas() {
      currentMinCellSize = window.innerWidth < 768 ? MIN_CELL_SIZE_MOBILE : MIN_CELL_SIZE_DESKTOP;
      const containerWidth = canvasContainer.clientWidth;
      const containerHeight = canvasContainer.clientHeight;

      if (containerWidth <= 0 || containerHeight <= 0) return;

      const oldCanvasWidth = canvas.width;
      const oldCanvasHeight = canvas.height;
      let centerXGrid = viewOffsetX + (oldCanvasWidth / 2 / (cellSize || currentMinCellSize)); // Use currentMinCellSize as fallback
      let centerYGrid = viewOffsetY + (oldCanvasHeight / 2 / (cellSize || currentMinCellSize));

      canvas.width = containerWidth;
      canvas.height = containerHeight;
      
      // Force pixelated rendering after resize, if supported
      ctx.imageSmoothingEnabled = false;


      if (initialCellSizeSetup) {
        let initialFitCellSize = Math.floor(Math.min(containerWidth / cols, containerHeight / rows));
        // On very small screens, if trying to fit all 80x80 cells makes them too small,
        // this will effectively zoom in a bit by ensuring a minimum visible size.
        if (window.innerWidth < 768) {
             initialFitCellSize = Math.floor(Math.min(containerWidth / (cols/1.5), containerHeight / (rows/1.5)));
        }

        cellSize = Math.max(currentMinCellSize, initialFitCellSize);
        viewOffsetX = (cols - containerWidth / cellSize) / 2; // Center grid initially
        viewOffsetY = (rows - containerHeight / cellSize) / 2;
        initialCellSizeSetup = false;
      } else {
        if (cellSize > 0) {
          viewOffsetX = centerXGrid - (canvas.width / 2 / cellSize);
          viewOffsetY = centerYGrid - (canvas.height / 2 / cellSize);
        } else {
          cellSize = currentMinCellSize; // Fallback if cellSize became invalid
          viewOffsetX = (cols - containerWidth / cellSize) / 2;
          viewOffsetY = (rows - containerHeight / cellSize) / 2;
        }
      }

      clampViewOffset();
      drawGrid();
    }

    function clampViewOffset() {
      if (typeof cellSize === 'undefined' || cellSize <= 0) return;

      // If grid is smaller than canvas, center it
      if (cols * cellSize < canvas.width) {
        viewOffsetX = (cols * cellSize - canvas.width) / (2 * cellSize);
      } else { // Otherwise, clamp to grid boundaries
        const minX = 0;
        const maxX = Math.max(0, cols - (canvas.width / cellSize)); // Ensure maxX is not negative
        viewOffsetX = Math.max(minX, Math.min(viewOffsetX, maxX));
      }

      if (rows * cellSize < canvas.height) {
        viewOffsetY = (rows * cellSize - canvas.height) / (2 * cellSize);
      } else {
        const minY = 0;
        const maxY = Math.max(0, rows - (canvas.height / cellSize)); // Ensure maxY is not negative
        viewOffsetY = Math.max(minY, Math.min(viewOffsetY, maxY));
      }
    }

    window.addEventListener('resize', resizeCanvas);
    // Also call resizeCanvas after a short delay for initial setup,
    // ensuring layout is stable.
    setTimeout(resizeCanvas, 50);


    toggleSidebarBtn.addEventListener('click', () => {
      sidebar.classList.toggle('collapsed');
      toggleSidebarBtn.textContent = sidebar.classList.contains('collapsed') ? 'â–¶' : 'â—€';
      // Recalculate canvas size after sidebar animation
      setTimeout(resizeCanvas, 310); // Wait for sidebar transition (0.3s) + a bit
    });

    createShapePreviews();
    // resizeCanvas(); // Called by setTimeout now

    // --- Zoom Logic ---
    function applyZoom(zoomFactor, mouseX, mouseY) {
        if (typeof cellSize === 'undefined') return;

        const mouseGridX_before = (mouseX / cellSize) + viewOffsetX;
        const mouseGridY_before = (mouseY / cellSize) + viewOffsetY;

        let newCellSize = cellSize * zoomFactor;
        newCellSize = Math.max(currentMinCellSize, Math.min(MAX_CELL_SIZE, newCellSize));

        if (newCellSize === cellSize) return;

        cellSize = newCellSize;

        viewOffsetX = mouseGridX_before - (mouseX / cellSize);
        viewOffsetY = mouseGridY_before - (mouseY / cellSize);

        clampViewOffset();
        drawGrid();
    }

    // Mouse Wheel Zoom
    canvas.addEventListener('wheel', (event) => {
      event.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;
      const zoomFactor = event.deltaY < 0 ? 1.1 : 0.9;
      applyZoom(zoomFactor, mouseX, mouseY);
    }, { passive: false }); // passive:false to allow preventDefault

    // --- Panning Logic (Mouse and Touch) ---
    function startPan(clientX, clientY) {
        isPanning = true;
        lastPanX = clientX;
        lastPanY = clientY;
        canvas.style.cursor = 'grabbing';
    }

    function movePan(clientX, clientY) {
        if (!isPanning || typeof cellSize === 'undefined' || cellSize <= 0) return;

        const dx = clientX - lastPanX;
        const dy = clientY - lastPanY;

        viewOffsetX -= dx / cellSize;
        viewOffsetY -= dy / cellSize;

        lastPanX = clientX;
        lastPanY = clientY;

        clampViewOffset();
        drawGrid();
    }

    function stopPan() {
        if (isPanning) {
            isPanning = false;
            canvas.style.cursor = running ? 'grab' : 'crosshair';
        }
        pinchStartDistance = null; // Reset pinch zoom tracking
    }

    // Mouse Panning
    canvas.addEventListener('mousedown', (event) => {
      if (event.button !== 0) return; // Only left mouse button
      // Prevent panning if a control button was the target of mousedown
      if (event.target !== canvas) return;
      startPan(event.clientX, event.clientY);
    });
    canvas.addEventListener('mousemove', (event) => {
      movePan(event.clientX, event.clientY);
    });
    // Stop panning on mouseup anywhere or if mouse leaves canvas
    window.addEventListener('mouseup', stopPan); // Changed from canvas to window
    canvas.addEventListener('mouseleave', stopPan);


    // Touch Panning & Pinch Zoom
    canvas.addEventListener('touchstart', (event) => {
        event.preventDefault(); // Prevent default touch actions like scrolling
        if (event.touches.length === 1) {
            startPan(event.touches[0].clientX, event.touches[0].clientY);
        } else if (event.touches.length === 2) {
            isPanning = false; // Stop single-touch panning if two fingers are down
            const dx = event.touches[0].clientX - event.touches[1].clientX;
            const dy = event.touches[0].clientY - event.touches[1].clientY;
            pinchStartDistance = Math.sqrt(dx * dx + dy * dy);
        }
    }, { passive: false });

    canvas.addEventListener('touchmove', (event) => {
        event.preventDefault();
        if (event.touches.length === 1 && isPanning) { // Ensure isPanning is true for single touch move
            movePan(event.touches[0].clientX, event.touches[0].clientY);
        } else if (event.touches.length === 2 && pinchStartDistance) {
            const dx = event.touches[0].clientX - event.touches[1].clientX;
            const dy = event.touches[0].clientY - event.touches[1].clientY;
            const currentDistance = Math.sqrt(dx * dx + dy * dy);
            const zoomFactor = currentDistance / pinchStartDistance;

            // Calculate center point for zoom
            const rect = canvas.getBoundingClientRect();
            const MclientX = (event.touches[0].clientX + event.touches[1].clientX) / 2;
            const MclientY = (event.touches[0].clientY + event.touches[1].clientY) / 2;
            const mouseX = MclientX - rect.left;
            const mouseY = MclientY - rect.top;

            applyZoom(zoomFactor, mouseX, mouseY);
            pinchStartDistance = currentDistance; // Update for continuous zoom
        }
    }, { passive: false });

    canvas.addEventListener('touchend', (event) => {
        // event.preventDefault(); // Not always needed for touchend, can sometimes interfere
        if (event.touches.length < 2) { // If less than 2 touches, pinch zoom ends
            pinchStartDistance = null;
        }
        if (event.touches.length < 1) { // If no touches left, panning ends
             stopPan();
        }
    });


    canvas.addEventListener('click', (event) => {
      if (running || typeof cellSize === 'undefined' || isPanning) return; // Don't toggle cells if panning just occurred
      
      // A small delay to distinguish from pan/drag end
      setTimeout(() => {
        if (isPanning) return; // Check again, as stopPan might have just set it

        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;

        const col = Math.floor(x / cellSize + viewOffsetX);
        const row = Math.floor(y / cellSize + viewOffsetY);

        if (row >= 0 && row < rows && col >= 0 && col < cols) {
          grid[row][col] = grid[row][col] ? 0 : 1;
          initialGrid[row][col] = grid[row][col];
          drawGrid();
        }
      }, 50); // 50ms delay, adjust if needed
    });

    canvas.addEventListener('dragover', (event) => {
      event.preventDefault();
    });

    canvas.addEventListener('drop', (event) => {
      event.preventDefault();
      if (typeof cellSize === 'undefined') return;

      const shapeName = event.dataTransfer.getData('text/plain');
      if (!shapeName || !shapes[shapeName]) return;

      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;

      const baseCol = Math.floor(x / cellSize + viewOffsetX);
      const baseRow = Math.floor(y / cellSize + viewOffsetY);
      const pattern = shapes[shapeName];

      pattern.forEach(([r, c]) => {
        const row = baseRow + r;
        const col = baseCol + c;
        if (row >= 0 && row < rows && col >= 0 && col < cols) {
          grid[row][col] = 1;
          if (!running) {
            initialGrid[row][col] = 1;
          }
        }
      });
      drawGrid();
    });

    startStopBtn.addEventListener('click', () => {
      if (!running) {
        running = true;
        startStopBtn.textContent = 'Stop';
        canvas.style.cursor = 'grab';
        initialGrid = grid.map(rowArray => rowArray.slice());
        runGame();
      } else {
        running = false;
        startStopBtn.textContent = 'Start';
        if (timeoutId) clearTimeout(timeoutId);
        canvas.style.cursor = isPanning ? 'grabbing' : 'crosshair';
      }
    });

    resetBtn.addEventListener('click', () => {
      if (running) {
        running = false;
        startStopBtn.textContent = 'Start';
        if (timeoutId) clearTimeout(timeoutId);
      }
      grid = initialGrid.map(rowArray => rowArray.slice());
      drawGrid();
      canvas.style.cursor = 'crosshair';
    });

    randomBtn.addEventListener('click', () => {
      if (running) {
        running = false;
        startStopBtn.textContent = 'Start';
        if (timeoutId) clearTimeout(timeoutId);
      }
      grid = Array.from({ length: rows }, () =>
        Array.from({ length: cols }, () => (Math.random() < 0.3 ? 1 : 0))
      );
      initialGrid = grid.map(rowArray => rowArray.slice());
      drawGrid();
      canvas.style.cursor = 'crosshair';
    });

    clearBtn.addEventListener('click', () => {
      if (running) {
        running = false;
        startStopBtn.textContent = 'Start';
        if (timeoutId) clearTimeout(timeoutId);
      }
      grid = createEmptyGrid();
      initialGrid = createEmptyGrid();
      drawGrid();
      canvas.style.cursor = 'crosshair';
    });

    speedRange.addEventListener('input', () => {
      speed = parseInt(speedRange.value, 10);
    });

    function createEmptyGrid() {
      return Array.from({ length: rows }, () => Array(cols).fill(0));
    }

    function drawGrid() {
      if (!ctx || !canvas.width || !canvas.height || typeof cellSize === 'undefined' || cellSize <= 0) {
        return;
      }
      ctx.imageSmoothingEnabled = false; // Ensure pixelated look
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#00FFFF'; // Live cell color
      ctx.strokeStyle = '#333';   // Grid line color
      
      // Adjust lineWidth based on cellSize for better visuals
      // Make lines thinner if cells are very small, but not invisible
      ctx.lineWidth = Math.max(0.1, Math.min(1, cellSize / 10));


      const buffer = 1; // Draw a bit outside the viewport to avoid visual gaps when panning
      const startCol = Math.floor(viewOffsetX - buffer);
      const endCol = Math.ceil(viewOffsetX + canvas.width / cellSize + buffer);
      const startRow = Math.floor(viewOffsetY - buffer);
      const endRow = Math.ceil(viewOffsetY + canvas.height / cellSize + buffer);

      for (let r = startRow; r < endRow; r++) {
        for (let c = startCol; c < endCol; c++) {
          // Wrap around for toroidal array, or skip if out of bounds
          // Current implementation doesn't wrap drawing, but logic does.
          // For drawing, we only care about the defined grid.
          if (r < 0 || r >= rows || c < 0 || c >= cols) continue;

          const screenX = (c - viewOffsetX) * cellSize;
          const screenY = (r - viewOffsetY) * cellSize;

          if (grid[r][c]) {
            // For very small cells, drawing a slightly smaller rect can look like a dot
            if (cellSize < 3) {
                 ctx.fillRect(screenX + ctx.lineWidth, screenY + ctx.lineWidth, cellSize - (ctx.lineWidth*2), cellSize - (ctx.lineWidth*2));
            } else {
                 ctx.fillRect(screenX, screenY, cellSize, cellSize);
            }
          }
          // Only draw grid lines if cells are large enough to see them
          if (cellSize > 3) {
            ctx.strokeRect(screenX, screenY, cellSize, cellSize);
          }
        }
      }
    }

    function getNextGrid() {
      const nextGrid = createEmptyGrid();
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const neighbors = countNeighbors(row, col);
          if (grid[row][col]) {
            nextGrid[row][col] = (neighbors === 2 || neighbors === 3) ? 1 : 0;
          } else {
            nextGrid[row][col] = (neighbors === 3) ? 1 : 0;
          }
        }
      }
      return nextGrid;
    }

    function countNeighbors(row, col) {
      let count = 0;
      for (let i = -1; i <= 1; i++) {
        for (let j = -1; j <= 1; j++) {
          if (i === 0 && j === 0) continue;
          const nRow = (row + i + rows) % rows; // Toroidal array logic
          const nCol = (col + j + cols) % cols; // Toroidal array logic
          if (grid[nRow] && typeof grid[nRow][nCol] !== 'undefined') {
             count += grid[nRow][nCol];
          }
        }
      }
      return count;
    }

    function runGame() {
      if (!running) return;
      grid = getNextGrid();
      drawGrid();
      timeoutId = setTimeout(() => {
        requestAnimationFrame(runGame); // Use rAF for smoother animation timing with setTimeout
      }, 1000 / speed);
    }

  </script>
</body>
</html>
